{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bayesian-EUCLID Readme The Bayesian-EUCLID framework offers a novel way to discover the model of hyperelastic materials using experimentally available displacement field and reaction force data. An overview of the procedure adopted in the code can be found in the figure below, which shows a schematic of Bayesian-EUCLID for unsupervised discovery of hyperelastic constitutive laws with uncertainties. In the figure, (a) A large library of constitutive features (inspired from physics-based and phenomenological models) is chosen for the hyperelastic strain energy density. (b) Sparsity promoting spike-slab priors are placed on the material parameters to induce bias towards parsimonious constitutive models. (c) The likelihood of the observed data (consisting of displacement data \u2013 including accelerations, if available \u2013 and reaction forces) is unsupervised and based on satisfying the physical constraint of linear momentum balance. Conditioned on the prior, the force residuals are modeled using a Gaussian likelihood. (d) Using Bayes\u2019 rule and Gibbs sampling, physically admissible, interpretable, and parsimonious constitutive models are discovered in the form of multi-modal posterior distributions with quantifiable epistemic and aleatoric uncertainties. Spike slab priors allow for efficient enforcement of parsimony in model selection. Compared to the previous work , this EUCLID framework provides significantly faster material discovery (of around 100 times), while using significantly lesser data (1/1000th number of quadrature data points). The documentation consists of a file-wise explanation of the code and an example file which illustrates the execution of the code to discover the model for a benchmark Arruda-Boyce material. The code and the Finite Element data used to generate the results shown in the Bayesian-EUCLID paper are available in the GitHub repository . The output of the code is a essentially the Markov chain used to sample the posterior probability distribution of the random variables (including features coefficients theta ). These feature coefficients are used to construct a plot saved in the ./drivers/plots folder.","title":"Home"},{"location":"#bayesian-euclid-readme","text":"The Bayesian-EUCLID framework offers a novel way to discover the model of hyperelastic materials using experimentally available displacement field and reaction force data. An overview of the procedure adopted in the code can be found in the figure below, which shows a schematic of Bayesian-EUCLID for unsupervised discovery of hyperelastic constitutive laws with uncertainties. In the figure, (a) A large library of constitutive features (inspired from physics-based and phenomenological models) is chosen for the hyperelastic strain energy density. (b) Sparsity promoting spike-slab priors are placed on the material parameters to induce bias towards parsimonious constitutive models. (c) The likelihood of the observed data (consisting of displacement data \u2013 including accelerations, if available \u2013 and reaction forces) is unsupervised and based on satisfying the physical constraint of linear momentum balance. Conditioned on the prior, the force residuals are modeled using a Gaussian likelihood. (d) Using Bayes\u2019 rule and Gibbs sampling, physically admissible, interpretable, and parsimonious constitutive models are discovered in the form of multi-modal posterior distributions with quantifiable epistemic and aleatoric uncertainties. Spike slab priors allow for efficient enforcement of parsimony in model selection. Compared to the previous work , this EUCLID framework provides significantly faster material discovery (of around 100 times), while using significantly lesser data (1/1000th number of quadrature data points). The documentation consists of a file-wise explanation of the code and an example file which illustrates the execution of the code to discover the model for a benchmark Arruda-Boyce material. The code and the Finite Element data used to generate the results shown in the Bayesian-EUCLID paper are available in the GitHub repository . The output of the code is a essentially the Markov chain used to sample the posterior probability distribution of the random variables (including features coefficients theta ). These feature coefficients are used to construct a plot saved in the ./drivers/plots folder.","title":"Bayesian-EUCLID Readme"},{"location":"code_data/","text":"Code Codes are available on GitHub . Data Data are available on GitHub .","title":"Code/Data"},{"location":"code_data/#code","text":"Codes are available on GitHub .","title":"Code"},{"location":"code_data/#data","text":"Data are available on GitHub .","title":"Data"},{"location":"publication/","text":"This browser does not support PDFs. Please download the PDF to view it: Download PDF .","title":"Publication"},{"location":"mdfiles/Example/","text":"Example for Arruda Boyce benchmark models In the following, we illustrate the use of the Bayesian-EUCLID to discover the model of a known benchmark material (Arruda-Boyce model) using displacement field data obtained from FEM simulations. Input format The benchmark FEM data folders- dyn-euclid-master-data (dynamic data) and euclid-master-data (quasistatic data) are structured as shown in the figure below Additional benchmark materials can be added in the format shown above. The only difference between dynamic and quasistatic data is that the former also includes nodal acceleration data in the output_nodes.csv file. Parameters and code execution The figure below shows a snippet of the config.py file, which contains the initialized parameters. lambda_r is the regularization parameter that is used in process_raw_data(...) function in unsupervised_hyperelasticity.py file. filter_value is the number of degrees of freedom subsampled from the available data at all quadrature points. In this case, at total of 100 degrees of freedom are subsampled from a total of 2752 data points. a_v, b_v, a_p, b_p, a_sigma and b_sigma are the hierarchical spike slab hyperparameters shown in Fig. 2 in the Bayesian-EUCLID paper . chain_length is the length of each individual Markov chain used to sample the posterior probability distribution. In this case a chain length of 1000 was used. burn is the number of initial elements of each formed chain that are discarded. In this case the first 250 elements of each chain were discarded. parallel_chains is the total number of chains used to sample the posterior probability distribution. A total of 4 chains were used in this work, which were later merged into a single chain of length 3000 elements, after the first 250 elements of each chain was discarded. theta_fiber and theta_fiber2 are the assumed orientation angles of the two fibers considered in the feature library. Two fibers suffice for the Holzapfel benchmark considered in this work. Also, as per the work by Dong and Sun, (2021) , any symmetrical distribution of arbitrary number fibers can be equivalently resolved into a two-fiber system along the directions of symmetry. Appendix C of the the Bayesian-EUCLID paper discusses the effect of assuming incorrect directions ( \\(\\pm45^{\\circ}\\) ) for the fibers. The figures below show snippets of code execution in Anaconda Powershell Prompt. The main_hss.py file is run with the shown arguments. In the first case, the quasistatic Arruda-Boyce benchmark data is selected, while in the second the dynamic Arruda-Boyce benchmark data is selected. The figure below shows a snippet of code progress as the chains are constructed and the energy plots are made. Code output The main output of the code is the chain object whose theta attribute contains a distribution of the discovered feature coefficients. These discovered feature coefficients are used to make the violin plots and energy evolution plots as shown below.","title":"Example"},{"location":"mdfiles/Example/#example-for-arruda-boyce-benchmark-models","text":"In the following, we illustrate the use of the Bayesian-EUCLID to discover the model of a known benchmark material (Arruda-Boyce model) using displacement field data obtained from FEM simulations.","title":"Example for Arruda Boyce benchmark models"},{"location":"mdfiles/Example/#input-format","text":"The benchmark FEM data folders- dyn-euclid-master-data (dynamic data) and euclid-master-data (quasistatic data) are structured as shown in the figure below Additional benchmark materials can be added in the format shown above. The only difference between dynamic and quasistatic data is that the former also includes nodal acceleration data in the output_nodes.csv file.","title":"Input format"},{"location":"mdfiles/Example/#parameters-and-code-execution","text":"The figure below shows a snippet of the config.py file, which contains the initialized parameters. lambda_r is the regularization parameter that is used in process_raw_data(...) function in unsupervised_hyperelasticity.py file. filter_value is the number of degrees of freedom subsampled from the available data at all quadrature points. In this case, at total of 100 degrees of freedom are subsampled from a total of 2752 data points. a_v, b_v, a_p, b_p, a_sigma and b_sigma are the hierarchical spike slab hyperparameters shown in Fig. 2 in the Bayesian-EUCLID paper . chain_length is the length of each individual Markov chain used to sample the posterior probability distribution. In this case a chain length of 1000 was used. burn is the number of initial elements of each formed chain that are discarded. In this case the first 250 elements of each chain were discarded. parallel_chains is the total number of chains used to sample the posterior probability distribution. A total of 4 chains were used in this work, which were later merged into a single chain of length 3000 elements, after the first 250 elements of each chain was discarded. theta_fiber and theta_fiber2 are the assumed orientation angles of the two fibers considered in the feature library. Two fibers suffice for the Holzapfel benchmark considered in this work. Also, as per the work by Dong and Sun, (2021) , any symmetrical distribution of arbitrary number fibers can be equivalently resolved into a two-fiber system along the directions of symmetry. Appendix C of the the Bayesian-EUCLID paper discusses the effect of assuming incorrect directions ( \\(\\pm45^{\\circ}\\) ) for the fibers. The figures below show snippets of code execution in Anaconda Powershell Prompt. The main_hss.py file is run with the shown arguments. In the first case, the quasistatic Arruda-Boyce benchmark data is selected, while in the second the dynamic Arruda-Boyce benchmark data is selected. The figure below shows a snippet of code progress as the chains are constructed and the energy plots are made.","title":"Parameters and code execution"},{"location":"mdfiles/Example/#code-output","text":"The main output of the code is the chain object whose theta attribute contains a distribution of the discovered feature coefficients. These discovered feature coefficients are used to make the violin plots and energy evolution plots as shown below.","title":"Code output"},{"location":"mdfiles/config/","text":"File description This file contains the parameters required for material discovery using Bayesian-EUCLID framework. Section 2 and Table A.2 in the paper discusses these parameters. Methods get_loadsteps(...): - Returns the loadsteps to be considered from the FEM data for the discovery process. get_feature_filter(...): - Returns feature_filter , which is a list of features to retain for constructing the Markov chain. Suppressed features will be highlighted with a red patch in the plot","title":"config"},{"location":"mdfiles/config/#file-description","text":"This file contains the parameters required for material discovery using Bayesian-EUCLID framework. Section 2 and Table A.2 in the paper discusses these parameters.","title":"File description"},{"location":"mdfiles/config/#methods","text":"get_loadsteps(...): - Returns the loadsteps to be considered from the FEM data for the discovery process. get_feature_filter(...): - Returns feature_filter , which is a list of features to retain for constructing the Markov chain. Suppressed features will be highlighted with a red patch in the plot","title":"Methods"},{"location":"mdfiles/core_spike_slab/","text":"class Chain: Refer to the hierarchical Bayesian model discussed in the Bayesian-EUCLID paper (Fig. 2) for details regarding the parameters. Attributes - p0 - Numpy array of length chain_length containing different values of \\(p_0\\) in the chain - vs - Numpy array of length chain_length containing different values of \\(\\nu_s\\) in the chain - sig2 - Numpy array of length chain_length containing different values of \\(\\sigma^2\\) in the chain - z - Numpy array of dimension chain_length X numFeatures (see features_library.py ) containing different values of z ( activity ) in the chain - theta - Numpy array of dimension chain_length X numFeatures (see features_library.py ) containing different values of theta ( feature coefficients ) in the chain - chain_length - burn - Number of elements of the chain discarded as burn in in sampling the posterior probability distribution. Methods - __init__(...): - Generates an object of class Chain - update_state(...): - Populates the chain with newly sampled state variables - combine_chain(...): - Combines different parallelly generated Markov chains - burn_chain(...): - Deletes the first burn number of elements of the chains class Data: class Params: class State:","title":"core_spike_slab"},{"location":"mdfiles/core_spike_slab/#class-chain","text":"Refer to the hierarchical Bayesian model discussed in the Bayesian-EUCLID paper (Fig. 2) for details regarding the parameters. Attributes - p0 - Numpy array of length chain_length containing different values of \\(p_0\\) in the chain - vs - Numpy array of length chain_length containing different values of \\(\\nu_s\\) in the chain - sig2 - Numpy array of length chain_length containing different values of \\(\\sigma^2\\) in the chain - z - Numpy array of dimension chain_length X numFeatures (see features_library.py ) containing different values of z ( activity ) in the chain - theta - Numpy array of dimension chain_length X numFeatures (see features_library.py ) containing different values of theta ( feature coefficients ) in the chain - chain_length - burn - Number of elements of the chain discarded as burn in in sampling the posterior probability distribution. Methods - __init__(...): - Generates an object of class Chain - update_state(...): - Populates the chain with newly sampled state variables - combine_chain(...): - Combines different parallelly generated Markov chains - burn_chain(...): - Deletes the first burn number of elements of the chains","title":"class Chain:"},{"location":"mdfiles/core_spike_slab/#class-data","text":"","title":"class Data:"},{"location":"mdfiles/core_spike_slab/#class-params","text":"","title":"class Params:"},{"location":"mdfiles/core_spike_slab/#class-state","text":"","title":"class State:"},{"location":"mdfiles/data_definitions/","text":"class Reference: class Reaction: class FeatureSet: class FemDataset:","title":"data_definitions"},{"location":"mdfiles/data_definitions/#class-reference","text":"","title":"class Reference:"},{"location":"mdfiles/data_definitions/#class-reaction","text":"","title":"class Reaction:"},{"location":"mdfiles/data_definitions/#class-featureset","text":"","title":"class FeatureSet:"},{"location":"mdfiles/data_definitions/#class-femdataset","text":"","title":"class FemDataset:"},{"location":"mdfiles/features_library/","text":"File description A total of numFeatures number of features are defined in the computeFeatures_torch function.","title":"Features library"},{"location":"mdfiles/features_library/#file-description","text":"A total of numFeatures number of features are defined in the computeFeatures_torch function.","title":"File description"},{"location":"mdfiles/helper/","text":"Methods show_current_time(): progressbar(...):","title":"helper"},{"location":"mdfiles/helper/#methods","text":"show_current_time(): progressbar(...):","title":"Methods"},{"location":"mdfiles/load_fem_data/","text":"","title":"Load fem data"},{"location":"mdfiles/main_hss/","text":"File description This is the main file to run launch the EUCLID-Bayesian code for material model discovery. The arguments to run the file are: 1. Benchmark material Name. Can be any one of the following: ArrudaBoyce, Holzapfel, ArrudaBoyce, Ogden3, NeoHookeanJ2, Isihara, HainesWilson, GentThomas, Ogden ) 2. Noise conditioning of the data (can be high , low or none ) 3. Whether the data is to be taken from the euclid-master-data folder (quasistatic) or the dyn-euclid-master-data folder (dynamic). Any string provided in this argument will result in the code selecting the dynamic data. Leave this argument blank if quasistatic data is to be selected for further analysis.","title":"main_hss"},{"location":"mdfiles/main_hss/#file-description","text":"This is the main file to run launch the EUCLID-Bayesian code for material model discovery. The arguments to run the file are: 1. Benchmark material Name. Can be any one of the following: ArrudaBoyce, Holzapfel, ArrudaBoyce, Ogden3, NeoHookeanJ2, Isihara, HainesWilson, GentThomas, Ogden ) 2. Noise conditioning of the data (can be high , low or none ) 3. Whether the data is to be taken from the euclid-master-data folder (quasistatic) or the dyn-euclid-master-data folder (dynamic). Any string provided in this argument will result in the code selecting the dynamic data. Leave this argument blank if quasistatic data is to be selected for further analysis.","title":"File description"},{"location":"mdfiles/post_process/","text":"","title":"Post process"},{"location":"mdfiles/preprocess_data/","text":"","title":"Preprocess data"},{"location":"mdfiles/truncated_multivariate_normal/","text":"","title":"Truncated multivariate normal"},{"location":"mdfiles/unsupervised_hyperelasticity/","text":"","title":"Unsupervised hyperelasticity"},{"location":"mdfiles/utilities/","text":"","title":"Utilities"},{"location":"myopts/features_library/","text":"computeFeatures_numpy(F11, F12, F21, F22): computeFeatures_torch(I1, I2, I3, Ia, Ib): Compute the features dependent on the right Cauchy-Green strain invariants. Note that the features only depend on I1 and I3 for plane strain assumption. Input Arguments I1 - 1st invariant I2 - 2nd invariant I3 - 3rd invariant Ia - Invariant along anisotropy direction. Ib - Invariant along second anisotropy direction. Output Arguments x - features get_mass_type(): get_theta_gt(fem_path, feature_filter): Returns the true feature coefficients corresponding to the benchmark material. getNumberOfFeatures(): Compute number of features. Input Arguments none Output Arguments features.shape[1] - number of features","title":"features_library"},{"location":"myopts/features_library/#computefeatures_numpyf11-f12-f21-f22","text":"","title":"computeFeatures_numpy(F11, F12, F21, F22):"},{"location":"myopts/features_library/#computefeatures_torchi1-i2-i3-ia-ib","text":"Compute the features dependent on the right Cauchy-Green strain invariants. Note that the features only depend on I1 and I3 for plane strain assumption. Input Arguments I1 - 1st invariant I2 - 2nd invariant I3 - 3rd invariant Ia - Invariant along anisotropy direction. Ib - Invariant along second anisotropy direction. Output Arguments x - features","title":"computeFeatures_torch(I1, I2, I3, Ia, Ib):"},{"location":"myopts/features_library/#get_mass_type","text":"","title":"get_mass_type():"},{"location":"myopts/features_library/#get_theta_gtfem_path-feature_filter","text":"Returns the true feature coefficients corresponding to the benchmark material.","title":"get_theta_gt(fem_path, feature_filter):"},{"location":"myopts/features_library/#getnumberoffeatures","text":"Compute number of features. Input Arguments none Output Arguments features.shape[1] - number of features","title":"getNumberOfFeatures():"},{"location":"myopts/load_fem_data/","text":"loadFemData(path, AD = True, noiseLevel = 0., noiseType = 'displacement', denoisedDisplacements = None): Load finite element data and add noise (optional). Note that the loaded finite element data might already be perturbed by noise. In that case, adding additional noise is not necessary. Input Arguments path - path to finite element data AD - specify if automatic differention is needed noiseLevel - noise level noiseType - a string list specifying whether noise should be added to 'displacement','strain','acceleration','velocity' denoisedDisplacements - pass denoised displacement data if available Output Arguments dataset - finite element dataset","title":"load_fem_data"},{"location":"myopts/load_fem_data/#loadfemdatapath-ad-true-noiselevel-0-noisetype-displacement-denoiseddisplacements-none","text":"Load finite element data and add noise (optional). Note that the loaded finite element data might already be perturbed by noise. In that case, adding additional noise is not necessary. Input Arguments path - path to finite element data AD - specify if automatic differention is needed noiseLevel - noise level noiseType - a string list specifying whether noise should be added to 'displacement','strain','acceleration','velocity' denoisedDisplacements - pass denoised displacement data if available Output Arguments dataset - finite element dataset","title":"loadFemData(path, AD = True, noiseLevel = 0., noiseType = 'displacement', denoisedDisplacements = None):"},{"location":"myopts/post_process/","text":"post_proc(chain, theta_gt, feature_filter, fem_mat, energy_func, fig_title, fig_title2, fig_dir = None, plotting=True, interactive_job=True): Making output plots containing a summary of the chains, and the corresponding predicted energies Input Arguments - chain - object of Chain class (see core_spike_slab file) - theta_gt - The true set of feature coefficients for the benchmark material - feature_filter - The list of features to retain for constructing the Markov chain. Suppressed features will be highlighted with a red patch in the plot - fem_mat - The name of the benchmark material to be tested - energy_func - The label of the function used to predict energy evolution for the discovered material along 6 different deformation paths - fig_title - Title displayed on the figure - fig_title2 - Filename of the saved figure (.png format) print_solution(theta):","title":"post_process"},{"location":"myopts/post_process/#post_procchain-theta_gt-feature_filter-fem_mat-energy_func-fig_title-fig_title2-fig_dir-none-plottingtrue-interactive_jobtrue","text":"Making output plots containing a summary of the chains, and the corresponding predicted energies Input Arguments - chain - object of Chain class (see core_spike_slab file) - theta_gt - The true set of feature coefficients for the benchmark material - feature_filter - The list of features to retain for constructing the Markov chain. Suppressed features will be highlighted with a red patch in the plot - fem_mat - The name of the benchmark material to be tested - energy_func - The label of the function used to predict energy evolution for the discovered material along 6 different deformation paths - fig_title - Title displayed on the figure - fig_title2 - Filename of the saved figure (.png format)","title":"post_proc(chain, theta_gt, feature_filter, fem_mat, energy_func, fig_title, fig_title2, fig_dir = None, plotting=True, interactive_job=True):"},{"location":"myopts/post_process/#print_solutiontheta","text":"","title":"print_solution(theta):"},{"location":"myopts/preprocess_data/","text":"extractSystemOfEquations(fem_dir,loadsteps): Processes nodal and element data at various load steps to assemble the linear equation [A1;lambda_r A2] theta = [b1;lambda_r*b2] Input Arguments - fem_dir - File path location for data from FEM simulations - loadsteps - The deformation steps from the FEM simulations used to discover the material properties","title":"preprocess_data"},{"location":"myopts/preprocess_data/#extractsystemofequationsfem_dirloadsteps","text":"Processes nodal and element data at various load steps to assemble the linear equation [A1;lambda_r A2] theta = [b1;lambda_r*b2] Input Arguments - fem_dir - File path location for data from FEM simulations - loadsteps - The deformation steps from the FEM simulations used to discover the material properties","title":"extractSystemOfEquations(fem_dir,loadsteps):"},{"location":"myopts/unsupervised_hyperelasticity/","text":"check_data_name_validity(fem_material,noise_level): filter_raw_data(rng, raw_data, filter_value): Randomly sub-sampling filter_value degrees of freedom from the data available at all quadrature points in raw_data Input Arguments - rng - Random number generator - raw_data - Contains D (derivatives of feature library) and y (inertia terms and reaction forces) evaluated at all quadrature points - filter_value - Number of degrees of freedom subsampled from the original data Output Arguments RawData(A1, b1, A2, b2, dof_x, dof_y) - Object of class RawData which is constructed from subsampled data get_data(rng, fem_dir, prefix, fem_material, noise_level, loadstep, feature_filter): predict_energy_path(chain, theta_gt, fem_mat, feature_filter, deformation): Predicts the energy deformation evolution for predicted and true material models along six deformation paths: i.) uniaxial tension, ii.) uniaxial compression, iii.) simple shear, iv.) biaxial tension, v.) biaxial compression, vi.) pure shear Input Arguments - chain - Object of class Chain (see core_spike_slab file) - theta_gt - The true set of feature coefficients for the benchmark material - fem_mat - The name of the benchmark material to be tested - feature_filter - The list of features to retain for constructing the Markov chain. Suppressed features will be highlighted with a red patch in the plot - deformation - Name of deformation path to be evaluated Output Arguments - gamma - Numpy array of different values for the deformation parameter - energy_mean - Energy corresponding to mean value of theta (feature coefficients) across different members of the Markov chain - energy_plus - 97.5 percentile energy branch across different members of the Markov chain - energy_minus - 2.5 percentile energy branch across different members of the Markov chain - energy_gt - Energy corresponding to the true feature coefficients - energy - Numpy array containing energy of all chain members at all deformation parameters process_raw_data(raw_data_set, lambda_r):","title":"unsupervised_hyperelasticity"},{"location":"myopts/unsupervised_hyperelasticity/#check_data_name_validityfem_materialnoise_level","text":"","title":"check_data_name_validity(fem_material,noise_level):"},{"location":"myopts/unsupervised_hyperelasticity/#filter_raw_datarng-raw_data-filter_value","text":"Randomly sub-sampling filter_value degrees of freedom from the data available at all quadrature points in raw_data Input Arguments - rng - Random number generator - raw_data - Contains D (derivatives of feature library) and y (inertia terms and reaction forces) evaluated at all quadrature points - filter_value - Number of degrees of freedom subsampled from the original data Output Arguments RawData(A1, b1, A2, b2, dof_x, dof_y) - Object of class RawData which is constructed from subsampled data","title":"filter_raw_data(rng, raw_data, filter_value):"},{"location":"myopts/unsupervised_hyperelasticity/#get_datarng-fem_dir-prefix-fem_material-noise_level-loadstep-feature_filter","text":"","title":"get_data(rng, fem_dir, prefix, fem_material, noise_level, loadstep, feature_filter):"},{"location":"myopts/unsupervised_hyperelasticity/#predict_energy_pathchain-theta_gt-fem_mat-feature_filter-deformation","text":"Predicts the energy deformation evolution for predicted and true material models along six deformation paths: i.) uniaxial tension, ii.) uniaxial compression, iii.) simple shear, iv.) biaxial tension, v.) biaxial compression, vi.) pure shear Input Arguments - chain - Object of class Chain (see core_spike_slab file) - theta_gt - The true set of feature coefficients for the benchmark material - fem_mat - The name of the benchmark material to be tested - feature_filter - The list of features to retain for constructing the Markov chain. Suppressed features will be highlighted with a red patch in the plot - deformation - Name of deformation path to be evaluated Output Arguments - gamma - Numpy array of different values for the deformation parameter - energy_mean - Energy corresponding to mean value of theta (feature coefficients) across different members of the Markov chain - energy_plus - 97.5 percentile energy branch across different members of the Markov chain - energy_minus - 2.5 percentile energy branch across different members of the Markov chain - energy_gt - Energy corresponding to the true feature coefficients - energy - Numpy array containing energy of all chain members at all deformation parameters","title":"predict_energy_path(chain, theta_gt, fem_mat, feature_filter, deformation):"},{"location":"myopts/unsupervised_hyperelasticity/#process_raw_dataraw_data_set-lambda_r","text":"","title":"process_raw_data(raw_data_set, lambda_r):"},{"location":"myopts/utilities/","text":"computeCauchyGreenStrain(F): Compute right Cauchy-Green strain tensor from deformation gradient. Input Arguments F - deformation gradient in Voigt notation Output Arguments C - Cauchy-Green strain tensor in Voigt notation computeJacobian(F): Compute Jacobian from deformation gradient. Input Arguments F - deformation gradient in Voigt notation Output Arguments J - Jacobian computeStrainInvariantDerivatives(F,i,secondDerivative=False): Compute derivatives of the invariants of the Cauchy-Green strain tensor with respect to the deformation gradient. Plane strain is assumed. Input Arguments F - deformation gradient in Voigt notation i - specify the invariant that should be differentiated- I1, I2, I3, Ia or Ib secondDerivative - specify if second derivative should be computed Output Arguments dIdF - derivative (note that the size of dIdF depends on the choice of secondDerivative ) computeStrainInvariants(C): Compute invariants of the Cauchy-Green strain tensor. Plane strain is assumed. Input Arguments C - Cauchy-Green strain tensor in Voigt notation Output Arguments I1 - 1st invariant I2 - 2nd invariant I3 - 3rd invariant computeTriangleArea(p1, p2, p3): Computing the area of a triangle with vertices at points p1, p2, p3 (2D).","title":"utilities"},{"location":"myopts/utilities/#computecauchygreenstrainf","text":"Compute right Cauchy-Green strain tensor from deformation gradient. Input Arguments F - deformation gradient in Voigt notation Output Arguments C - Cauchy-Green strain tensor in Voigt notation","title":"computeCauchyGreenStrain(F):"},{"location":"myopts/utilities/#computejacobianf","text":"Compute Jacobian from deformation gradient. Input Arguments F - deformation gradient in Voigt notation Output Arguments J - Jacobian","title":"computeJacobian(F):"},{"location":"myopts/utilities/#computestraininvariantderivativesfisecondderivativefalse","text":"Compute derivatives of the invariants of the Cauchy-Green strain tensor with respect to the deformation gradient. Plane strain is assumed. Input Arguments F - deformation gradient in Voigt notation i - specify the invariant that should be differentiated- I1, I2, I3, Ia or Ib secondDerivative - specify if second derivative should be computed Output Arguments dIdF - derivative (note that the size of dIdF depends on the choice of secondDerivative )","title":"computeStrainInvariantDerivatives(F,i,secondDerivative=False):"},{"location":"myopts/utilities/#computestraininvariantsc","text":"Compute invariants of the Cauchy-Green strain tensor. Plane strain is assumed. Input Arguments C - Cauchy-Green strain tensor in Voigt notation Output Arguments I1 - 1st invariant I2 - 2nd invariant I3 - 3rd invariant","title":"computeStrainInvariants(C):"},{"location":"myopts/utilities/#computetriangleareap1-p2-p3","text":"Computing the area of a triangle with vertices at points p1, p2, p3 (2D).","title":"computeTriangleArea(p1, p2, p3):"}]}